"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import datetime
from enum import Enum
from investec_za_pb.types import BaseModel
from investec_za_pb.utils import FieldMetadata, PathParamMetadata
import pydantic
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class AccountsPendingTransactionsRequestTypedDict(TypedDict):
    account_id: str


class AccountsPendingTransactionsRequest(BaseModel):
    account_id: Annotated[
        str,
        pydantic.Field(alias="accountId"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]


class AccountsPendingTransactionsType(str, Enum):
    CREDIT = "CREDIT"
    DEBIT = "DEBIT"


class AccountsPendingTransactionsStatus(str, Enum):
    POSTED = "POSTED"
    PENDING = "PENDING"


class PendingTransactionTypedDict(TypedDict):
    account_id: NotRequired[str]
    r"""A unique and immutable identifier used to identify the account resource. This identifier has no meaning to the account owner."""
    type: NotRequired[AccountsPendingTransactionsType]
    status: NotRequired[AccountsPendingTransactionsStatus]
    description: NotRequired[str]
    r"""Unique identifier for the transaction within an servicing institution. This identifier is both unique and immutable."""
    transaction_date: NotRequired[datetime]
    r"""Date and time at which assets become available to the account owner in case of a credit entry, or cease to be available to the account owner in case of a debit transaction entry.
    Usage: If transaction entry status is pending and value date is present, then the value date refers to an expected/requested value date.
    For transaction entries subject to availability/float and for which availability information is provided, the value date must not be used. In this case the availability component identifies the number of availability days.
    All dates in the JSON payloads are represented in ISO 8601 date-time format.
    All date-time fields in responses must include the timezone. An example is below:
    2017-04-05T10:43:07+00:00
    """
    amount: NotRequired[float]
    r"""A number of monetary units specified in an active currency where the unit of currency is explicit and compliant with ISO 4217."""


class PendingTransaction(BaseModel):
    account_id: Annotated[Optional[str], pydantic.Field(alias="accountId")] = None
    r"""A unique and immutable identifier used to identify the account resource. This identifier has no meaning to the account owner."""

    type: Optional[AccountsPendingTransactionsType] = None

    status: Optional[AccountsPendingTransactionsStatus] = None

    description: Optional[str] = None
    r"""Unique identifier for the transaction within an servicing institution. This identifier is both unique and immutable."""

    transaction_date: Annotated[
        Optional[datetime], pydantic.Field(alias="transactionDate")
    ] = None
    r"""Date and time at which assets become available to the account owner in case of a credit entry, or cease to be available to the account owner in case of a debit transaction entry.
    Usage: If transaction entry status is pending and value date is present, then the value date refers to an expected/requested value date.
    For transaction entries subject to availability/float and for which availability information is provided, the value date must not be used. In this case the availability component identifies the number of availability days.
    All dates in the JSON payloads are represented in ISO 8601 date-time format.
    All date-time fields in responses must include the timezone. An example is below:
    2017-04-05T10:43:07+00:00
    """

    amount: Optional[float] = None
    r"""A number of monetary units specified in an active currency where the unit of currency is explicit and compliant with ISO 4217."""


class AccountsPendingTransactionsDataTypedDict(TypedDict):
    pending_transaction: NotRequired[List[PendingTransactionTypedDict]]


class AccountsPendingTransactionsData(BaseModel):
    pending_transaction: Annotated[
        Optional[List[PendingTransaction]], pydantic.Field(alias="PendingTransaction")
    ] = None


class AccountsPendingTransactionsLinksTypedDict(TypedDict):
    r"""Links relevant to the payload"""

    self_: str


class AccountsPendingTransactionsLinks(BaseModel):
    r"""Links relevant to the payload"""

    self_: Annotated[str, pydantic.Field(alias="self")]


class AccountsPendingTransactionsMetaTypedDict(TypedDict):
    r"""Meta Data relevant to the payload"""

    total_pages: NotRequired[int]


class AccountsPendingTransactionsMeta(BaseModel):
    r"""Meta Data relevant to the payload"""

    total_pages: Annotated[Optional[int], pydantic.Field(alias="totalPages")] = None


class AccountsPendingTransactionsResponseBodyTypedDict(TypedDict):
    r"""Resource has been retrieved"""

    data: AccountsPendingTransactionsDataTypedDict
    links: AccountsPendingTransactionsLinksTypedDict
    r"""Links relevant to the payload"""
    meta: AccountsPendingTransactionsMetaTypedDict
    r"""Meta Data relevant to the payload"""


class AccountsPendingTransactionsResponseBody(BaseModel):
    r"""Resource has been retrieved"""

    data: AccountsPendingTransactionsData

    links: AccountsPendingTransactionsLinks
    r"""Links relevant to the payload"""

    meta: AccountsPendingTransactionsMeta
    r"""Meta Data relevant to the payload"""
